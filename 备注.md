# 文件结构

```
TreeSynth/

├── config.py # 配置：API 设置、生成超参数

├── main.py # 主入口点：数据生成工作流控制

├── generator_math_async.py # MATH 风格数据集生成器

├── generator_code_async.py # Code Alpaca 风格数据集生成器

├── generator_gsm_async.py # GSM8K 风格数据集生成器

├── generator_mental_async.py # SimpleToM 风格数据集生成器

├── generator_mental_positive.py # Positive SimpleToM 风格数据集生成器

├── balance_mental.py # SimpleToM 风格数据平衡工具

├── vllm_engine.sh # vLLM 本地部署脚本

├── vllm_chat_template_llama3.1_json.jinja # vLLM 聊天模板

└── image/ # 文档图片目录
```

# config.py

```
#树shen
DEFAULT_CONFIG = {

"max_depth": 4, # 最大树深度

"num_samples_per_node": 10, # 每个节点生成的样本数

"max_attribute_count": 50, # 每个节点的最大属性数

"max_sample_infinite_attribute": 50, # 无限属性的阈值

"infinite_path_samples": 10, # 无限路径的样本数

"max_workers": 64, # 并发工作线程数

"max_concurrent_requests": 64, # 并发 API 请求数

"max_retries": 5, # 最大重试次数

}
```





# ChatAnywhere

sk-XmIRSMlKzuvKnKeOFlErHL9iHIKAjPSvCyEP92GxQuubRv0h

```python
from openai import OpenAI

client = OpenAI(
    # defaults to os.environ.get("OPENAI_API_KEY")
    api_key="sk-XmIRSMlKzuvKnKeOFlErHL9iHIKAjPSvCyEP92GxQuubRv0h",
    base_url="https://api.chatanywhere.tech/v1"#国内中转，延时更低
    # base_url="https://api.chatanywhere.org/v1"#国外使用
)
```





# 调试相关

20260108_221029_复现调试

## generator_math_async

控制台信息：代码output文件夹 中的 my_debug.txt

```
2026-01-08 22:11:44,261 - INFO - Tree structure saved (full tree) to output/20260108_221029/tree_structure.txt.
2026-01-08 22:11:44,281 - INFO - Tree structure saved (full tree) to output/20260108_221029/tree_structure.txt.
2026-01-08 22:11:44,301 - INFO - Tree structure saved (full tree) to output/20260108_221029/tree_structure.txt.
2026-01-08 22:11:44,301 - ERROR - Root node has no samples after expansion.
```

报错原因：并非生成失败，而是最后的判断逻辑有问题，generator_math_async生成,根节点并没有基于生成的 枢轴样本来确定划分准者和分类属性,而是人为规定

> ```
> ...
> 2026-01-08 22:11:44,301 - INFO - Tree structure saved (full tree) to output/...
> 2026-01-08 22:11:44,301 - ERROR - Root node has no samples after expansion.
> ```
>
> 错误发生在最后一次保存树结构之后。说明 BFS（广度优先搜索）循环已经全部跑完了，代码在做最后的收尾检查。
>
> ###  代码逻辑根源
>
> 问题的根源在于 `_expand_single_node_async` 函数中对 **Root 节点** 的特殊处理逻辑，与主程序结束时的 **校验逻辑** 冲突了。
>
> **根节点是一个纯粹的“容器”**，它只负责分发任务给 7 个数学领域的子节点，它自己是不生成题目的，也不持有题目。
>
> #### 主程序的校验逻辑 (推测)
>
> 在 `run_generation_process` 或 `main` 函数的末尾，很可能有一句类似这样的防御性代码：
>
> Python
>
> ```
> # 伪代码：主程序末尾
> await root.expand_nodes_async(...)
> 
> # 罪魁祸首在这里：
> if not root.samples: 
>     logger.error("Root node has no samples after expansion.")
> ```
>
> 因为 Root 节点的 `self.samples` 确实是 `None`（因为它把活儿都派给子节点干了），所以触发了这个 `ERROR`。

**==结尾判断逻辑修改后：==**

```
# 如果是 Root 节点，允许它没有 samples，只要它有 children 就行
if not root.samples and not root.children:
    logger.error("Root node has no samples and no children after expansion.")
elif not root.samples:
    logger.info("Root node expansion complete (Data acts as a container).")
```

> **修改前：**
>
> 
>
> ```python
> if not root.samples:
>     logger.error("Root node has no samples after expansion.")
> ```





# 代码改进

## generator_math_async

我的想法大致是这样的，我希望将 数据空间树 的构建过程变成动态的，这样我联想到了蒙特卡洛树搜索（解决序列决策问题，而当前构建 空间树 的过程中，唯一能够体现序列决策问题的地方体现在： 通过LLM生成的l个枢轴样本 来决定 划分准则 这一关键步骤；而通过l个枢轴样本和划分准则划分准则确定的 分类属性值 是都需要的，并非取其中一个，所以我认为无法融入MCTS的思想）。如下两个关键问题：

1.树的深度动态控制——当前阶段，划分准则 是LLM由l个枢轴样本决定的，所以，在完全信任LLM的情况下，如何提升l个枢轴（问题）样本的多样性和质量是关键的，针对该问题，解决办法如下： **由原本的一次性生成枢轴样本（当前代码逻辑） 转为 迭代式生成（每次生成一个）**，直观地可以发现：树的深度就可以进行动态控制，当前节点下（子空间下）的枢轴样本个数只能生成一个（或者相对较少时）直接将其作为叶子节点，完全无需使用当前超参数的设置来控制树的深度。

> - **操作流程**（不再是一次性生成 10 个）：
>   1. **种子生成**：让 LLM 生成第 1 个样本 $x_1$。
>   2. **对抗式生成**：
>      - Prompt: “你已经生成了 $x_1$ 。请生成一个在**语义逻辑、场景或解法上完全不同**的新样本 $x_2$。”
>      - Prompt: “你已经有了 $\{x_1, ..., x_n\}$ 。请生成一个与上述所有样本都**互斥**的新样本。”
>   3. **饱和度计算**：
>      - 计算每次新生成的样本与历史样本库的**最大相似度**（Max Cosine Similarity）。
>      - 如果相似度迅速飙升到接近 1（比如生成到第 3 个就开始重复了），说明**空间饱和**。
> - **判定**：
>   - **快速饱和** $\rightarrow$  节点空间狭窄 $\rightarrow$  **停止划分**。
>   - **难以饱和**（生成了 20 个依然差异巨大） $\rightarrow$  节点空间广阔 $\rightarrow$  **继续划分**。
> - **优势**：这实际上是在对 LLM 进行**压力测试**。如果连逼着它写不同它都写不出来，那就是真的没东西可分了，而不是它“偷懒”。

你需要修改的代码逻辑（我目前想到的，如果不足你可进行完善）

- format_gen_prompt提示词的修改，使得LLM可以迭代式的生成，以及generate_samples_async中获取响应的逻辑和 正则表达式匹配的逻辑。
- 判断叶子节点的逻辑，无需使用超参数，而是根据当前节点（子空间）能够尽最大努力生成的 枢轴样本的个数来决定

2.树的宽度（树节点的孩子个数）——我打算融入MSTC的思想（选择、扩展、模拟、反向传播四个阶段），并非完全能够动态控制当前节点，目前初步尝试一下策略，从MSTC的四个阶段（选择、扩展、模拟、反向传播）分别阐述
探索阶段：设定每个节点由LLM决定**两个** 划分准则，用于**序列决策**，根据当前代码逻辑，即树节点的定义方式（每个节点具备 dimension和attribute_value属性，也就是说在此改动下，如果dim1有5个attribute_value，dim2有6个attribute_value，那么当前节点将会 衍生出 5+6=11个孩子节点，这是值得 注意的代码逻辑，并非两个划分准则 就有两个孩子节点）。 选择 没有尝试过的 划分准则（严格来说是 分类属性）进行扩展

扩展阶段：对当前划分准则下的子节点由LLM为每个子节点（当前子空间）空间生成 枢轴样本（严格按照1.树的深度动态控制中的策略），进入模拟
模拟阶段：汇总当前划分准则下所有分类属性值（子节点下）的所有枢轴样本，统一计算 **Diversity**（通过嵌入空间的余弦相似度衡量,数值越低表示多样性越高），也就是每个划分准则（可能包含多个分类属性）模拟得到一个Diversity 得分。

反向传播：将得分反向传播回去，用于决定当前节点选择哪个 划分准则更好，也就是一个节点最终一定能确定一个划分准则（被判断为叶子节点的除外）


你需要修改的代码逻辑（我目前想到的，如果不足你可进行完善）

- 目前的主体生成逻辑是BFS，expand_nodes_async函数，所需要修改的地方在于 需要额外的一个 **决策函数（需要你来编写）**来决定 哪个划分准则（上述MCTS思想的四个步骤会确定当前节点使用哪个划分准则，二选一）被确定下来，并加入被决定的划分准则下的子节点（TreeNode的属性需要额外补充一个 是否是有效节点的信号，用于决定哪些节点（某一划分准则下的分类属性）加入队列）进入队列，即确保BFS的队列中是最终确定下来的节点。



请你思考我针对两个问题的解决方案，如果有不足，请你补充，等最终确定改善策略后，才需要你编写完整代码，当前无需编写代码。



针对你提出的建议我做如下决定：
第一部分：树的深度动态控制（迭代式枢轴样本生成）
1.嵌入模型暂且引入 OpenAI 的 `text-embedding-3-small`，毕竟是尝试阶段，就暂且引入这个嵌入模型，同时设定一个 `SATURATION_THRESHOLD`（例如 0.85）。如果连续 $K$ （增加config.py中的超参数，原本的超参数如下）次生成的样本与历史样本相似度 > 0.85，则判定饱和

> ```
> DEFAULT_CONFIG = {
>     "max_depth": 2,#4
>     "num_samples_per_node": 10,#10
>     "max_attribute_count": 25,#50
>     "max_sample_infinite_attribute": 25,#50
>     "infinite_path_samples": 10,#10
>     # "infinite_path_samples": 5,
>     "max_workers": 64,#64
>     "max_concurrent_requests": 64,#64
>     "max_retries": 5,#5
> }
> ```

2.我提出的串行策略确实不太好，改为采用采用 **小批次迭代**，mini_batch（增加config.py中的超参数）

3.**叶子节点判定的双重标准**：**Case A（空间狭窄）**：生成了 3-5 个样本就饱和了；**Case B（达到最大深度）**：虽然还没饱和（还能生成），但为了防止树无限深，达到硬性 `max_depth` （保留config.py中的max_depth超参数）限制强制停止 $\rightarrow$ **叶子节点**（此时需继续生成直到达到预设数量或饱和）。

第二部分：树的宽度动态控制（类 MCTS 的维度选择）

1.允许你所提出的 **模拟阶段**：不要虚拟构建，尽管该dim被舍弃，也要显示地保存在output.json和tree_structure.txt中方便我debug，同时新增一个TreeNode的一个属性值diversity_score,作为当前节点对应的一个划分准则 下所有分类属性 生成的样本 的多样性得分（这样我在最终debug的时候，观察output.json和tree_structure.txt可以轻易的判断出哪些子树被 舍弃了）

2.多样性得分：暂且简单计算（模拟阶段的）当前划分准则下所有分类属性 对应生成样本整体的相似性，采用最直接的指标最大余弦相似度（Max Cosine Similarity）

第三部分：系统架构修改建议
允许新增 `Sampler` 类 (对应问题 1)、新增 `DecisionMaker` 类 (对应问题 2)、 修改 `TreeNode` 和 BFS 流程



无限节点处理

> 经过我的思考，我发现对于无限节点的处理仍然有逻辑疏漏。
>
> 
>
> 原本静态构建树的过程中，将无限节点视为一个节点，当使用BFS扩展到某个节点（如果被判定为叶子节点），回溯其到根节点的完整路径，这个过程中如果检索到路径上有无限节点（其属性是一个列表，随机选择一个属性，作为当前层的一个子空间），直至到当前叶子节点，可得到该子空间完整的 维度和分类属性值（可视为约束当前子空间的属性）。
>
> 
>
> 现在是结合MCTS的动态构建，在决策哪个 维度更好时，如果候选维度中有一个是无限节点（当前方便调试，强行设置 为两个候选维度），另一个是普通节点， 所以模拟策略上就有了争议，对于普通节点 可以生成其维度下每个属性的枢轴样本，进而计算所有样本的diversity，那么对于无限节点，应该选哪些 分类属性去生成响应的枢轴样本计算diversity？







## 正确逻辑

> 这两个函数构成了整个 **TreeSynth** 系统的骨架（调度器）和血肉（执行逻辑）。为了方便你检查逻辑是否闭环，我将它们概括为 **“宏观调度层”** 和 **“微观决策层”** 两个部分进行解析。
>
> ### 1. 宏观调度层：`expand_nodes_async`
>
> **核心逻辑：基于队列的广度优先搜索 (BFS) 并发调度器**
>
> 这个函数负责管理整棵树的生长节奏，确保每一层的节点都能并发处理，并在层级之间同步状态。
>
> - **初始化与启动**：
>   - 保存初始空树结构。
>   - 先处理 **根节点**（调用其单节点逻辑），获取第一批子节点。
>   - 将第一批子节点放入双端队列 `queue`。
> - **层级循环 (While Queue)**：
>   - **分层处理**：记录当前层的节点数量 `level_size`，确保每次循环只处理这一层的节点。
>   - **并发分发**：遍历当前层的所有节点，为每个节点创建一个异步任务 `asyncio.create_task(node._expand_single_node_async)`。
>   - **并发执行**：使用 `await asyncio.gather(*tasks)` 同时运行这一层所有节点的扩展逻辑（这是高效率的关键）。
> - **结果收集与推进**：
>   - **收集赢家**：`gather` 返回的是每一组任务的 `active_children`（即 MCTS 选出的胜出分支）。
>   - **入队**：将这些胜出节点加入 `queue`，作为下一层的待处理节点。
>   - **保存状态**：每处理完一层，立即更新可视化的树结构文件 `tree_structure_file`。
>
> ------
>
> ### 2. 微观决策层：`_expand_single_node_async`
>
> **核心逻辑：基于 MCTS 的动态子空间划分流水线**
>
> 这个函数是算法的大脑，负责在一个具体的节点上，通过“生成-扩展-模拟-决策”的闭环来决定树的分支走向。
>
> **流程概括：**
>
> 1. **最大深度熔断 (Max Depth Check)**：
>    - **判断**：如果层级已满 (`depth >= max_depth`)。
>    - **动作**：强制停止分裂。如果该节点还没生成过样本，就地生成并保存。返回空列表（不再产生后代）。
> 2. **枢轴样本准备 (Pivot Preparation)**：
>    - **复用机制**：检查 `self.samples` 是否已有数据（来自上一轮 MCTS 模拟的遗产）。如果有，直接复用（极大提升效率）。
>    - **生成机制**：如果没有，调用 `IterativeSampler` 进行迭代生成。
>    - **饱和熔断**：如果竭尽全力也生成不了几个样本（空间狭窄），直接停止分裂，视为叶子节点。
> 3. **候选维度提案 (Brainstorming)**：
>    - **动作**：基于枢轴样本，让 LLM 提出 $N$ 个可能的划分维度（Candidates）。
> 4. **预扩展与建树 (Pre-Expansion & Construction) —— [关键修正点]**：
>    - **目的**：在决策前建立全量视图，解决“决策后扩展导致无限节点判定失效”的问题。
>    - **循环处理**：对每一个候选维度：
>      - **属性补全**：立即调用 LLM 扩展该维度下的所有属性。
>      - **拓扑判定**：
>        - **无限节点 (Infinite)**：如果属性过多，创建一个 **聚合节点**。
>        - **有限节点 (Finite)**：如果属性正常，创建多个 **普通子节点**。
>      - **挂载**：将这些节点全部挂载到 `self.children`，并将它们分组存入 `candidate_node_groups`。
> 5. **MCTS 决策 (MCTS Decision)**：
>    - **动作**：将准备好的节点组交给 `decision_maker`。
>    - **内部逻辑**：对节点组进行真实生成（模拟），计算多样性得分，选出最佳维度，标记 `is_selected`。
>    - **返回**：只返回胜出维度对应的子节点列表 `active_children`。
> 6. **状态保存 (Save)**：
>    - 将包含所有尝试记录（含被舍弃的分支）的树结构保存到 `output.json`，用于调试。
> 7. **返回下一层任务**：
>    - 返回 `active_children` 给 BFS 调度器。
>
> ### 逻辑自检清单（供你思考）
>
> 根据现在的代码结构：
>
> 1. **数据流是否断裂？** 没有。MCTS 模拟生成的数据存储在 `child.samples` 中，子节点被返回给 BFS，BFS 下一轮调用该子节点的 `_expand` 时，会命中 **步骤 2** 的复用逻辑，实现了无缝衔接。
> 2. **无限节点判定是否及时？** 是的。在 **步骤 4** 中，MCTS 介入之前就已经完成了属性扩展和判定，确保了 MCTS 评估的是正确的拓扑结构（是评测一个大聚合节点，还是评测一堆小节点）。
> 3. **被舍弃的节点去哪了？** 它们留在了 `self.children` 里（用于 `output.json` 记录），但没有被返回给 `active_children`，因此不会进入 BFS 队列，从此停止生长（Dead Branch）。
>
> 目前的逻辑看起来是非常严密且闭环的。

## 调试

- [x] 迭代生成直至饱和，目前都是达到最大限制，考虑将相似度限制调低点

  从0.85调成0.75

![Snipaste_2026-01-12_17-26-24](./%E5%A4%87%E6%B3%A8.assets/Snipaste_2026-01-12_17-26-24.png)

- [x] 提前判断是否可以得到划分维度（如果通过的话确实和后面 生成多个候选维度有些重复）

  解决，后面 迭代生成复用

![Snipaste_2026-01-12_17-44-22](./%E5%A4%87%E6%B3%A8.assets/Snipaste_2026-01-12_17-44-22.png)

- [x] 生成候选划分准则和分类属性正确

  

![image-20260112174525823](./%E5%A4%87%E6%B3%A8.assets/image-20260112174525823.png)

- [x] 超参数混用

  ```
  max_samples_per_node 这个是枢轴样本个数限制
  max_attribute_count  这个是节点属性限制
  
  
  ```



- [x] 扩展提示词无法保证 新生成的潜在属性值与现有互斥

改用余弦相似度来来进行过滤，逻辑类似 枢轴样本迭代生成

- [x] 无法避免会生成 attr/attr 以及 格式不正确的情况

  修改了提示词，明确指明了禁止相关的格式，并且增加了 re 的清晰操作

  > 
  >
  > ['==Purchasing/Selling==', 'Allocation/Distribution', 'Construction/Organizing', 'Travel/Distance', 'Inventory/Capacity', 'Design/Measurement', 'Transportation/Navigation', 'Food Preparation/Cooking', 'Communication/Language', 'Healthcare/Wellness', 'Entertainment/Recreation', 'Education/Learning', 'Environmental/Resource Management', 'Safety/Emergency Response', 'Media/Information', 'Social Interaction/Relationships', 'Arts/Crafts', 'Science/Experiments', 'Music/Sound', 'Math/Calculation', 'History/Time', 'Weather/Climate', 'Animals/Nature', 'Technology/Devices', 'Games/Strategy', 'Fashion/Clothing', '- Financial Literacy/Budgeting', '==-== Home Living/Housekeeping', '- Civic Engagement/Community Service', '- Gardening/Plant Care', '- Personal Development/Hobbies', '- Friendship/Teamwork', '- Celebrations/Festivals', '- Pets/Caregiving', '- Holiday Traditions/Cultural Practices', '- Fitness/Exercise', 'Sports/Physical Activities', 'Tools/Equipment Use', 'Emotions/Feelings', 'Occupations/Careers', 'Human Rights/Citizenship', 'Waste Management/Reuse', 'Economic Systems/Trade', 'Animal Habitats/Ecosystems', 'Space/Astronomy']

- [ ] 选择最佳候选 划分维度 模拟阶段，当前是随机挑选节点，有问题




### 关键保留

根节点
候选维度

> 'type_of_operation' 5+30
>
> ['addition', 'subtraction', 'multiplication', 'division', 'combination_operations']
>
> ['addition', 'subtraction', 'multiplication', 'division', 'combination_operations', 'exponentiation', 'root_extraction', 'comparison', 'measuring', 'counting', 'sequencing', 'pattern_recognition', 'approximation', 'estimation', 'graphing', 'measurement_conversion', 'data_interpretation', 'probability', 'logic_reasoning', 'time_telling', 'money_handling', 'geometry_identification', 'spatial_reasoning', 'unit_conversion', 'fractions_handling', 'equation_solving', 'variable_identification', 'pattern_completion', 'sequence_generation', 'shape_identification', 'area_calculation', 'perimeter_calculation', 'volume_calculation', 'angle_measurement', 'percentage_calculation']
>
> 'context' 24+30
>
> ['gift_distribution', 'school_supplies', 'community_service', 'charity_event', 'bake_sale', 'school_event_setup', 'book_club', 'wedding_preparation', 'personal_training', 'personal_bake_sale', 'personal_project', 'toy_car_race', 'gardening', 'social_gathering', 'photo_album_creation', 'friendship_projects', 'personal_bookshelf', 'movie_marathon', 'toy_car_party_game', 'animal_shelter_volunteering', 'sports_event_preparation', 'charity_event_running', 'garden_planting', 'school_event_preparation']
>
> ['gift_distribution', 'school_supplies', 'community_service', 'charity_event', 'bake_sale', 'school_event_setup', 'book_club', 'wedding_preparation', 'personal_training', 'personal_bake_sale', 'personal_project', 'toy_car_race', 'gardening', 'social_gathering', 'photo_album_creation', 'friendship_projects', 'personal_bookshelf', 'movie_marathon', 'toy_car_party_game', 'animal_shelter_volunteering', 'sports_event_preparation', 'charity_event_running', 'garden_planting', 'school_event_preparation', 'craft_activity', 'nature_walk', 'team_sports', 'storytelling_session', 'science_experiment', 'music_practice', 'recycling_project', 'cultural_exhibition', 'math_contest', 'language_club', 'art_class', 'robotics_club', 'volleyball_training', 'playground_cleanup', 'watercolor_painting', 'origami_workshop', 'building_blocks_contest', 'jigsaw_puzzle_challenge', 'campfire_story_session', 'animal_care_workshop', 'puppet_show', 'kite_flying', 'magic_show', 'zoo_visit', 'picnic_day', 'circus_outing', 'sandcastle_building', 'musical_chairs_game', 'farm_visit', 'science_fair']







## 待完善

1.提示词还原，不要刚开始增加换行符

